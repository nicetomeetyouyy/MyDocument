### 1.相关名词术语

* 同步和异步：同步是指：当程序1调用程序2时，程序1停下不动，直到程序2完成回到程序1来，程序1才继续执行下去。.异步是指：当程序1调用程序2时，程序1径自继续自己的下一个动作，不受程序2的的影响

* 死锁

  两个或两个以上的线程在等待不可能释放的资源，而导致剩下的任务无法完成为死锁

* 并发和并行

  并发：多个任务交替执行（看起来像同时执行）

  并行：多个任务同时执行

* 临界区

  表示公共资源或者共享数据

* 阻塞和非阻塞

  当有线程占用临界区资源，其他也需要这个临界区资源的线程也必须等待，等待会导致线程挂起，这就是阻塞。

  非阻塞与之相反，没有一个线程会妨碍其他线程的执行

* 并发级别：

  * 阻塞
  * 无饥饿
  * 无障碍：线程可以同时进入临界区，有冲突回滚操作
  * 无锁
  * 无等待

* Amdahl定律

  提升系统效率，增加CPU处理器数量加速效果也有限，还需要从根本上更改程序，提高可并行化模块



### 2.volatile关键字

#### java 内存模型中的可见性、原子性和有序性

* 可见性：

  当多个线程访问同一个变量x时，线程1修改了变量x的值，线程1、线程2...线程n能够立即读取到线程1修改后的值。

* 原子性：

  即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行
  
* 有序性：
即程序执行的顺序按照代码的先后顺序执行





#### volatile的定义和基础

volatile是轻量级的synchronized，修饰在需要共享的变量上。

关键字volatile的作用是强制从公共堆栈中获得变量的值，而不是从线程私有数据栈取得变量的值，

![1569567720403](picture/1569567720403.png)



volatile增加了实例变量在多个线程之间的可见性，但它不支持原子性

* 和synchronized比较：
  * volatile性能比synchronized好，只能修饰变量，而ssynchronized能修饰方法、代码块。
  * 多线程访问volatile不会发生阻塞，synchronized会出现阻塞
  * synchronized可以保证原子性，也可以间接保证可见性。
  * volatile解决的是**变量在线程之间的可见性**，synchronized解决的是**多个线程之间访问资源的同步性**





### 3.线程间通信

#### 等待/通知机制

* wait（）方法

  该方法能使当前执行代码的线程进行等待，为Object类的方法，在wait（）所在的代码行处停止执行。直到被通知或被中断为止

  在调用wait（）前，线程必须获得该对象级别的锁，即只能在同步代码块或者同步方法中调用该方法。没有持有相应的锁时，抛出IllegalMonitorStateException。

* notify（）方法

  该方法的使用和wait（）一样。如果有多个线程在等待，由线程规划器挑选出一个wait状态的线程，使它等待获取该对象的锁。

  notify线程不会马上释放对象锁，执行notify线程的将程序执行完（synchronized代码块）才会释放锁，切没有notify（）继续通知的话，其他还在等待该对象的锁还会继续等待。

![1569575318971](picture/1569575318971.png)





  


